./init/init.c:#include <env.h>
./user/include/lib.h:#include <env.h>
./user/include/lib.h:extern volatile struct Env* env;
./user/lib/wait.c:#include <env.h>
./user/lib/pipe.c:#include <env.h>
./user/lib/pipe.c:	debugf("[%08x] pipecreate \n",env->env_id);
./user/lib/pipe.c:		runs = env->env_runs;
./user/lib/pipe.c:	} while(runs != env->env_runs);
./user/lib/fork.c:#include <env.h>
./user/lib/fork.c:	extern volatile struct Env* env;
./user/lib/fork.c:	if (env->env_cow_entry != (u_int)cow_entry) {
./user/lib/fork.c:		env = envs + ENVX(ecall_getenvid());
./user/lib/fork.c:		curenv_pgdir = env->env_pgdir;
./user/lib/ipc.c:#include <env.h>
./user/lib/ipc.c:		*whom = env->env_ipc_from;
./user/lib/ipc.c:		*perm = env->env_ipc_perm;
./user/lib/ipc.c:	return env->env_ipc_value;
./user/lib/libos.c:#include <env.h>
./user/lib/libos.c:volatile struct Env* env;
./user/lib/libos.c:	env = &envs[ENVX(ecall_getenvid())];
./user/lib/libos.c:	curenv_pgdir = env->env_pgdir;
./user/lib/libos.c:	//debugf("env is %08x\n",env);
./user/lib/ecall_lib.c:#include<env.h>
./user/lib/fd.c:#include <env.h>
./user/lib/fd.c:	debugf("[%08x] unknown device type %d\n",env->env_id,dev_id);
./user/lib/spawn.c:#include <env.h>
./user/lib/fsipc.c:#include <env.h>
./kern/env.c:#include <env.h>
./kern/env.c:	struct Env* env = (struct Env* )data;
./kern/env.c:	return page_insert(env->env_pgdir,env->env_asid,p,va,perm);
./kern/env.c:	printk("[%08x] free env %08x \n",curenv?curenv->env_id:0,e->env_id);
./kern/traps.c:#include <env.h>
./kern/ecall_all.c:#include <env.h>
./kern/ecall_all.c:	struct Env* env;
./kern/ecall_all.c:	try(envid2env(envid,&env,1));
./kern/ecall_all.c:	return page_insert(env->env_pgdir,env->env_asid,pp,va,perm);
./kern/ecall_all.c:	struct Env* env;
./kern/ecall_all.c:	try(envid2env(envid,&env,1));
./kern/ecall_all.c:	if (env->env_status == ENV_RUNNABLE && status == ENV_NOT_RUNNABLE) {
./kern/ecall_all.c:		TAILQ_REMOVE(&env_sched_list,env,env_sched_link);
./kern/ecall_all.c:	else if (env->env_status == ENV_NOT_RUNNABLE && status == ENV_RUNNABLE) {
./kern/ecall_all.c:		TAILQ_INSERT_TAIL(&env_sched_list,env,env_sched_link);
./kern/ecall_all.c:	env->env_status = status;
./kern/ecall_all.c:	struct Env* env;
./kern/ecall_all.c:	try(envid2env(envid,&env,1));
./kern/ecall_all.c:	if (env == curenv) {
./kern/ecall_all.c:		env->env_tf = *tf;
./kern/pmap.c:#include<env.h>
./kern/sched.c:#include <env.h>
./kern/include.mk:targets             :=  printk.o panic.o pmap.o env.o entry.o traps.o genex.o env_asm.o sched.o ecall_all.o console.o virtio_disk.o
./11:riscv64-unknown-elf-gcc --std=gnu99  -g  -fno-pic -ffreestanding -nostartfiles -fno-stack-protector -fno-builtin -Wall -march=rv32imaf -mabi=ilp32f  -O0 -g -ggdb -DMOS_DEBUG --std=gnu99  -g  -fno-pic -ffreestanding -nostartfiles -fno-stack-protector -fno-builtin -Wall -march=rv32imaf -mabi=ilp32f  -O0 -g -ggdb -DMOS_DEBUG -I../include/ -c -o env.o env.c
./11:attempt to open kern/env.o succeeded
./11:kern/env.o
./temp:[00000800] free env 00000800 
./temp:[00002000] free env 00002000 
./temp:[00002800] free env 00002800 
./temp:[00003000] free env 00003000 
./temp:[00003800] free env 00003800 
./temp:[00004000] free env 00004000 
./temp:[00004800] free env 00004800 
./temp:[00005000] free env 00005000 
./temp:[00005800] free env 00005800 
./temp:[00006000] free env 00006000 
./temp:[00006800] free env 00006800 
./temp:[00007000] free env 00007000 
./temp:[00007800] free env 00007800 
./temp:[00008000] free env 00008000 
./temp:[00008800] free env 00008800 
./temp:[00009000] free env 00009000 
./temp:[00009800] free env 00009800 
./temp:[0000a000] free env 0000a000 
./temp:[0000a800] free env 0000a800 
./temp:[0000b000] free env 0000b000 
./temp:[0000b800] free env 0000b800 
./temp:[0000c000] free env 0000c000 
./temp:[0000c800] free env 0000c800 
./temp:[0000d000] free env 0000d000 
./temp:[0000d800] free env 0000d800 
./temp:[0000e000] free env 0000e000 
./temp:[0000e800] free env 0000e800 
./temp:[0000f000] free env 0000f000 
./temp:[0000f800] free env 0000f800 
./temp:[00010000] free env 00010000 
./temp:[00010800] free env 00010800 
./temp:[00011000] free env 00011000 
./temp:[00011800] free env 00011800 
./temp:[00012000] free env 00012000 
./temp:[00012800] free env 00012800 
./temp:[00013000] free env 00013000 
./temp:[00013800] free env 00013800 
./temp:[00014000] free env 00014000 
./temp:[00014800] free env 00014800 
./temp:[00015000] free env 00015000 
./temp:[00015800] free env 00015800 
./temp:[00016000] free env 00016000 
./temp:[00016800] free env 00016800 
./temp:[00017000] free env 00017000 
./temp:[00017800] free env 00017800 
./.git/logs/HEAD:de5816bda2dd6b05c3a1b1fa17e31bf506d4fdaa d7c26e87a8d632771b327bfc50865e6a5286e4d7 db <1716911340@qq.com> 1684735163 +0800	commit: nearly finished ,but the file system need to map the address to the ee env
./.git/logs/refs/heads/lab5file-user:de5816bda2dd6b05c3a1b1fa17e31bf506d4fdaa d7c26e87a8d632771b327bfc50865e6a5286e4d7 db <1716911340@qq.com> 1684735163 +0800	commit: nearly finished ,but the file system need to map the address to the ee env
./include/error.h:// Attempt to send to env that is not recving.
./include/env.h:	u_int env_parent_id;	  // env_id of this env's parent
./include/env.h:	u_int env_ipc_recving; // env is blocked receiving
./include/env.h:extern struct Env *curenv;		     // the current env
./include/env.h:extern struct Env_sched_list env_sched_list; // runnable env list
